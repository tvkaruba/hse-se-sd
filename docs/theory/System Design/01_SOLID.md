# SOLID

SOLID это акроним для набора практик проектирования программного кода и построения гибкой и адаптивной системы. Данный термин был введен известным американским специалистом в области программирования Робертом Мартином. Сам акроним образован по первым буквам названий SOLID-принципов:

* **S**ingle Responsibility Principle (Принцип единственной обязанности)
* **O**pen/Closed Principle (Принцип открытости/закрытости)
* **L**iskov Substitution Principle (Принцип подстановки Лисков)
* **I**nterface Segregation Principle (Принцип разделения интерфейсов)
* **D**ependency Inversion Principle (Принцип инверсии зависимостей)

## Принцип единственной обязанности (SRP)

*A class should have only one reason to change. (с) Robert C. Martin*

Класс должен быть ответственен лишь за что-то одно. Если класс отвечает за решение нескольких задач, его подсистемы, реализующие решение этих задач, оказываются связанными друг с другом. Изменения в одной такой подсистеме ведут к изменениям в другой. Этот принцип применим не только к классам, но и к компонентам программного обеспечения в более широком смысле.

![Мухи и котлеты](/res/imgs/solid1.png)

SRP — это принцип, объясняющий как декомпозировать, то есть где провести линию разделения. Он говорит, что декомпозировать надо по принципу разделения "ответственности", то есть по задачам тех или иных объектов. Но, также, мы не должны слишком мельчить. То, что изменяется вместе, должно храниться в одном месте, то есть, если мы меняем логировку операции, то мы должны это менять в одном месте. Иными словами, SRP не только требует "дробить пока дробится", но и не перестараться — "не раздробить сцепленные вещи".

Пример:

```kt
class User(var name: String, var аge: Int) { }

/*
class UserDeserializer {
    fun deserialize(json): User {...}
}

class UserSerializer {
    fun serialize(user): String {...}
}
*/

class UserSerializer {
    fun deserialize(json): User {...}
    fun serialize(user): String {...}
}
```

### Бритва Оккама

Методологический принцип, в кратком виде гласящий: *Не следует привлекать новые сущности без крайней на то необходимости.*

В начале проектирования, программист часто не знает всех тонкостей решаемой задачи и может ошибаться, но ошибаться можно по разному:

* Сделать слишком большие объекты, склеив разные ответственности;
* Передробить, разделив единую ответственность на много разных типов;
* Неверно определить границы ответственности.

И почти всегда ошибаться лучше в большую сторону, если в вашем классе собрано несколько ответственностей, то он все еще понятен и его легко можно разделить с минимальным изменением в логике, но обратный процесс обычно куда сложнее.

## Принцип открытости/закрытости (OCP)

*Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification (с) Bertrand Meyer*

Программные сущности должны быть открыты для расширения, но не для модификации.

Главной концепцией данного принципа является то, что класс должен быть открыт для расширений, но закрыт от модификаций. Наш модуль должен быть разработан так, чтобы новая функциональность могла быть добавлена только при создании новых требований.

Тут будет пример про вычисление площадей фигур...

## Принцип подстановки Лисков (LSP)

Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом.

Данный принцип гласит, что вы должны иметь возможность использовать любой производный класс вместо родительского класса и вести себя с ним таким же образом без внесения изменений. Этот принцип прост, но очень важен для понимания. Производный класс не должен нарушать определение типа родительского класса и его поведение.

Тут пример про наследника с нереализованным методом...

## Принцип разделения интерфейсов (ISP)

Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.

Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы программные сущности маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться программные сущности, которые этот метод не используют. Как и в случае с принципом единственной ответственности, цель принципа разделения интерфейса заключается в минимизации побочных эффектов и повторов за счёт разделения ПО на независимые части.

## Принцип инверсии зависимостей (DIP)

Зависимость на Абстракциях. Нет зависимости на что-то конкретное.

Вобще, полная формулировка звучит так:
* Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
* Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Классы высокого уровня реализуют бизнес-правила или логику в системе. Низкоуровневые классы занимаются более подробными операциями, другими словами, они могут заниматься записью информации в базу данных или передачей сообщений в операционную систему или службы и т.п.

Высокоуровневый класс, который имеет зависимость от классов низкого уровня или какого-либо другого класса и много знает о других классах, с которыми он взаимодействует, тесно связан. Когда класс явно знает о дизайне и реализации другого класса, возникает риск того, что изменения в одном классе нарушат другой класс, поэтому мы должны держать эти высокоуровневые и низкоуровневые классы слабо связанными, насколько мы можем. Чтобы сделать это, нам нужно сделать их зависимыми от абстракций, а не друг от друга.

Пример про отправку репортов...

## Ссылки

* [SOLID в картинках](https://habr.com/ru/companies/productivity_inside/articles/505430/)
* [GRASP](https://ru.wikipedia.org/wiki/GRASP)