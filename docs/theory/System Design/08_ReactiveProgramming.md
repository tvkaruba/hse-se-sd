# Реактивное программирование

## Введение

Что такое реактивное программирование? Нет, это не Rx*. Реактивное программирование — парадигма программирования, предполагающая передачу ответственности за инициализацию обработки информации источнику информации.

Это определение — описание того общего, что есть у Rx, Akka и т.д. Да, все эти библиотеки отличаются внешним API, но подкапотные механизмы одни и те же — динамический список подписчиков и какое-то условие его обхода. Это очень простая механика, и она встречается постоянно.

Паттерны реактивного программирования предполагают разворачивание направления связей в нашем коде, позволяя одним модулям зависеть от других, не меняя их код. Иначе говоря, реактивное программирование позволяет уменьшить связанность кода.


![img1](/res/imgs/rx1.png)

Хорошей практикой при разработке приложений является разделение их на независимые модули/компоненты/фичи. Но надо понимать, что эти модули не существуют сами по себе, и цельное приложение получается из их связанности. Сложный вопрос — как описывать эти связи и где их хранить.

Реактивное программирование прекрасно решает проблемы высокой связности за счёт простого трюка — связи между модулей переносятся из кода в рантайм. В коде мы лишь описываем, что хотели бы получить, но не описываем как. Реактивные паттерны позволяют убрать код, но оставить логическую связь, образовав её в рантайме. Как мы знаем, лучший код тот, что не написан.

Еще одна интересная тема при использовании реактивного подхода - работа с инвалидацией кэша. Мы знаем, что связи в нашей системе никуда не делись, но перенеслись из кода в рантайм, и рантаймом этим управляет какой-то утилитарный код. И зная все места хранения данных и связи между ними, можно легко отслеживать инвалидацию данных и их связей. Но это сложная тема, поэтому я только упомяну об этом. :)

### Немного о проблемах

Мы привносим больше работы в рантайм конструируя ещё один уровень абстракции, мы забираем память на его обслуживание (в большей степени) и в некоторых случаях вычислительную производительность (в меньшей степени). Но частично это компенсируется тем, что мы уменьшим количество вычислений в доменном коде. Большей проблемой является сложность дебага дополнительных структур в рантайме. Данные уже нельзя просто увидеть в переменной, гуляя по коду с отладчиком, нужно запросить их из реактивного контейнера.

А самой большой проблемой, является непонимание, когда эту реактивность применять, а когда нет. Внедряя реактивные интерфейсы в наш код, мы его красим. Как асинхронные функции заставляют везде писать await, чтобы получить из них данные, так и реактивные примитивы удобно использовать только тогда, когда весь код на них опирается. В итоге, процессы описанные через реактивные интерфейсы, тупо сложнее читать, приходится постоянно прыгать глазами по коду. Не коллбэк хэлл, но бывает где-то близко.

![img2](/res/imgs/rx2.svg)

Давайте вспомним определение, что реактивность — способ разбиения кода. Зачем, например, разбивать код единого процесса? В этом нет никакого смысла. Помимо связанности у нас есть и зацепленность, иногда эти понятия путают, но в английском они строго определены: сoupling и cohesion. Мы немного говорили об этом когда затрагивали GRASP.

Модули системы должны быть отвязаны друг от друга, но внутри, наоборот, они должны быть полностью сцеплены. Иначе говоря, процессы должны быть максимально последовательны, линейны и императивны. Чаще всего, контейнер доменной (бизнес) логики — это не данные, а процессы, которые описывают условия и правила их трансформации и изменения. Это самая сложная и важная часть кода приложения. Она должна описываться максимально просто.

И все это кстати было о реактивных потоках, на уровне приложений обычно используют их, но так же можно использовать и акторную модель (Akka), что требует более комплексного внедрения, зато позволяет использовать их в распределенных системах.

## Ближе к практике...

Давайте начнем с определения Pull и Push коллекций... Pull коллекции — это то, к чему мы все привыкли в программировании. Самый яркий пример — массив. В нём уже есть данные, сам он эти данные не поменяет, но может отдать по запросу. А теперь давайте представим, что изначально в коллекции нет данных, но она обязательно сообщит о том, что они появились (Push). И в то же время мы всё так же можем к этой коллекции применять нужные трансформации.

```kt
val list = listOf("1", "2", "3", "4", "5")
list.toObservable()
    .subscribeBy(
        onNext = { println(it) },
        onError = { it.printStackTrace() },
        onComplete = { println("onComplete!") })
```

Cold observables

* Уведомляют о событиях, когда на них кто-то подписывается.
* Весь поток данных отправляется заново каждому подписчику независимо от времени подписки.
* Данные копируются для каждого подписчика.

Hot observables

* Пытаются уведомлять о событии независимо от наличия подписчиков. Если на момент события не было подписчиков — данные теряются.

## Практика

На самом деле в котлин есть несколько вариантов реализации реактивных потоков: RxJava, RxKotlin и Corutines+Flow. Последний конечно очередной велосипед от JB, давайте посмотрим на него.

```kt
launch {
    flow { 
        emit(1)
        emit(2)
        emit(3)
    }
    .map {
        printThread(«map1 value = $it»)
        it + it
    }
    .onEach { printThread(«after map1 -> $it») }
    .flowOn(Dispatchers.IO)
    .map {
        printThread(«map2 value = $it»)
        it * it
    }
    .onEach { printThread(«after map2 -> $it») }
    .flowOn(Dispatchers.Default)
	    .onCompletion { printThread(«onCompletion») }
    .collect { printThread(«received value $it») }
}
```

flowOn определяет диспетчер выполнения для предыдущих операторов. Метод collect() будет выполняться в том же диспетчере, что и launch, а emit данных будет происходить в Dispatchers.IO.

Flow имеет стандартные методы создания flow:

* flowOf(): в примере можно было бы использовать Observable.fromArray(1, 2, 3) и flowOf(1, 2, 3)
* extenstion function asFlow(), который превращает Iterable, Sequence, массивы во flow
* билдер flow { }

В данном примере Flow представляет собой cold stream данных: до вызова метода collect() никакой обработки происходить не будет. Метод onCompletion() будет автоматически вызываться после окончания блока flow { }

---

В Flow метод collect() — suspend метод, он может быть запущен только внутри корутины. А отписка от flow происходит в момент отмены Job корутины:

```kt
val job = scope.launch { 
flow.collect { } 
} 
job.cancel()
```

В андройде можно использовать viewModelScope или lifecycleScope, тогда заботиться об этом не нужно, все подписки будут отменены при уничтожение скоупа.

---

В Flow для обработки ошибок есть метод catch(). Под капотом он имеет вид привычной конструкции try/catch.

```kt
flowOf(1, 2, 3)
    .map {
        val divider = Random.Default.nextInt(0, 1)
        it / divider
    }
    .catch { e -> println(e) }
    .collect { println(it) }
```

---

Backpressure – это ситуация, когда производитель данных выдает элементы подписчику быстрее, чем тот их может обработать. Готовые данные, в ожидании того, как подписчик сможет их обработать, складываются в буфер Observable. Проблема такого подхода в том, что буфер может переполниться, вызвав OutOfMemoryError.

У Flow backpressure заложена в Kotlin suspending functions. Если сборщик flow не может принимать новые данные в настоящий момент, он приостанавливает источник. Возобновление происходит позднее, когда сборщик flow снова сможет получать данные.

---

В Kotlin Flow есть возможности для работы с горячим flow, который производит данные вне зависимости от наличия подписчиков и выдает новые данные одновременно всем имеющимся подписчикам. Для этого можно использовать Channel, SharedFlow.

---

Subject в RxJava – это специальный элемент, который одновременно является источником данных и подписчиком. Он может подписаться на один или несколько источников данных, получать от них порции данных и отдавать их своим подписчикам.

В Flow есть специальный элемент, который одновременно является источником данных и подписчиком. Он может подписаться на один или несколько источников данных, получать от них порции данных и отдавать их своим подписчикам. Это Channel, существуют различные варианты их реализации: с буферизацией данных (ArrayBroadcastChannel), с хранением только последнего элемента (ConflatedBroadcastChannel)...

## Что почитать

* https://www.reactivemanifesto.org/ - манифест о том что реактивщина за все хорошее и против всего плохого :)