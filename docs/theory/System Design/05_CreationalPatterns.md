# Порождающие паттерны

## Фабричный метод

### Описание

Фабричный метод — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

![Фабричный метод](/res/imgs/pattern1.png)

Представьте, что вы создаёте программу управления грузовыми перевозками. Сперва вы рассчитываете перевозить товары только на автомобилях. Поэтому весь ваш код работает с объектами класса Грузовик.

В какой-то момент ваша программа становится настолько известной, что морские перевозчики выстраиваются в очередь и просят добавить поддержку морской логистики в программу.

Отличные новости! Вот только большая часть существующего кода жёстко привязана к классам Грузовиков. Но чтобы добавить в программу ещё один вид транспорта, вам придется перелопатить весь код. А потом еще раз для следующего... И в итоге вы получите говнокод, с кучей условных операторов, которые выполняют то или иное действие, в зависимости от класса транспорта.

Паттерн Фабричный метод предлагает создавать объекты не напрямую, а через вызов особого фабричного метода. На первый взгляд, это может показаться бессмысленным: мы просто переместили вызов конструктора из одного конца программы в другой. Но теперь вы сможете переопределить фабричный метод в подклассе, чтобы изменить тип создаваемого продукта.

Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс, тогда подклассы смогут производить объекты различных классов, следующих одному и тому же интерфейсу.

### Пример

![Фабричный метод](/res/imgs/pattern2.png)

```kt
interface Document {
    fun showDocumentInfo()
}

class DrawingDocument : Document {
    override fun showDocumentInfo() {
        println("This is a drawing document")
    }
}

class WordDocument : Document {
    override fun showDocumentInfo() {
        println("This is a word document")
    }
}

abstract class Application {
    abstract fun createDocument(): Document

    companion object {
        fun getApplicationDocument(documentType: DocumentType): Application {
            return when (documentType) {
                DocumentType.Drawing -> DrawingApplication()
                DocumentType.Word -> WordApplication()
                else -> throw Exception("Invalid document type")
            }
        }
    }
}

class DrawingApplication : Application() {
    override fun createDocument() = DrawingDocument()
}

class WordApplication : Application() {
    override fun createDocument() = WordDocument()
}
```

## Абстрактная фабрика

### Описание

Абстрактная фабрика — это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.

![Абстрактная фабрика](/res/imgs/pattern3.png)

По смыслу это то же самое что и фабричный метод, только более обобщенное.

### Пример

![Абстрактная фабрика](/res/imgs/pattern4.png)

```kt
open class Vegetation
class Cactus : Vegetation()
class Tree : Vegetation()

open class Terrain
class Sand : Terrain()
class Grass : Terrain()

interface Factory {
    fun createTerrain() : Terrain
    fun createVegetation() : Vegetation
}

class DesertFactory : Factory {

    override fun createTerrain() : Terrain {
        return Sand()
    }

    override fun createVegetation() : Vegetation {
        return Cactus()
    }
}

class ForrestFactory : Factory {

    override fun createTerrain(): Terrain {
        return Grass()
    }

    override fun createVegetation(): Vegetation {
        return Tree()
    }
}

class GameMap(val factory : Factory) {
    private lateinit var terrain : Terrain
    private lateinit var tree : Vegetation

    init {
        terrain = factory.createTerrain()
        tree = factory.createVegetation()
    }
}
```

## Билдер (Строитель)

### Описание

Строитель — это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

![Строитель](/res/imgs/pattern5.png)

Представьте сложный объект, требующий пошаговой инициализации множества полей и вложенных объектов. Код инициализации таких объектов обычно спрятан внутри монструозного конструктора с десятком параметров. Либо ещё хуже — распылён по всему клиентскому коду.

Например, давайте подумаем о том, как создать объект Дом. Чтобы построить стандартный дом, нужно поставить 4 стены, установить двери, вставить пару окон и положить крышу. Но что, если вы хотите дом побольше да посветлее, имеющий сад, бассейн и прочее?

Самое простое решение — расширить класс Дом, создав подклассы для всех комбинаций параметров дома. Проблема такого подхода — это громадное количество классов, которые вам придётся создать. Чтобы не плодить подклассы, вы можете подойти к решению с другой стороны. Вы можете создать гигантский конструктор Дома, принимающий уйму параметров для контроля над создаваемым продуктом. Действительно, это избавит вас от подклассов, но приведёт к другой проблеме - монструозному списку параметров половина из которых не используются.

Паттерн Строитель предлагает вынести конструирование объекта за пределы его собственного класса, поручив это дело отдельным объектам, называемым строителями.

![Строитель](/res/imgs/pattern6.png)

Паттерн предлагает разбить процесс конструирования объекта на отдельные шаги (например, построитьСтены, вставитьДвери и другие). Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя. Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации.

### Пример

![Строитель](/res/imgs/pattern7.png)

```kt
class Person() {
    var name = ""
    var address = ""
    var age = 0
    
    fun setName(name : String) : Person {
        this.name = name
        return this
    }
    
    fun setAddress(address : String) : Person {
        this.address = address
        return this
    }
    
    fun setAge(age : Int) : Person {
        this.age = age
        return this
    }       
}

val person = Person()
person
    .setName("Tom")
    .setAddress("Street")
    .setAge(18)
```

## Прототип

### Описание

Прототип — это порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации.

![Прототип](/res/imgs/pattern8.png)

У вас есть объект, который нужно скопировать. Как это сделать? Нужно создать пустой объект такого же класса, а затем поочерёдно скопировать значения всех полей из старого объекта в новый.

Но не каждый объект удастся скопировать таким образом, ведь часть его состояния может быть приватной, а значит — недоступной для остального кода программы. Eсть и другая проблема. Копирующий код станет зависим от классов копируемых объектов. Ведь, чтобы перебрать все поля объекта, нужно привязаться к его классу.

Паттерн Прототип поручает создание копий самим копируемым объектам. Он вводит общий интерфейс для всех объектов, поддерживающих клонирование. Это позволяет копировать объекты, не привязываясь к их конкретным классам. Обычно такой интерфейс имеет всего один метод clone. Метод создаёт новый объект текущего класса и копирует в него значения всех полей собственного объекта.

### Пример

Тут пример как это сделать просто, но для комплексных примеров вам таки придется делать метод клонирования ручками.

```kt
data class Visitor(val date: String, val identification: String, val isVip: Boolean)

val ordinaryVisitor = Visitor("12/30/2019", "123456790", false)
val famousVisitor = ordinaryVisitor.copy(isVip = true)
```

## Синглтон (Одиночка)

### Описание

Одиночка — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

![Одиночка](/res/imgs/pattern9.png)

Одиночка решает сразу две проблемы:
1. Гарантирует наличие единственного экземпляра класса. Чаще всего это полезно для доступа к какому-то общему ресурсу, например, базе данных.
2. Предоставляет глобальную точку доступа. Это не просто глобальная переменная, через которую можно достучаться к определённому объекту. Глобальные переменные не защищены от записи, поэтому любой код может подменять их значения без вашего ведома.

Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и создать публичный статический метод, который и будет контролировать жизненный цикл объекта-одиночки. Если у вас есть доступ к классу одиночки, значит, будет доступ и к этому статическому методу. Из какой точки кода вы бы его ни вызвали, он всегда будет отдавать один и тот же объект.

### Пример

В котлине это по сути часть языка...

```kt
object PrinterDriver {
    init {
        println("Initializing with object: $this")
    }

    fun print() = println("Printing with object: $this")
}
```

## Ленивая инициализация

### Описание

Отложенная инициализация - это паттерн позволяющий отложить действия, связанные с созданием объекта, до момента, когда непосредственно потребуется результат этих действий.

Данный шаблон используется если создание объекта связано с большими затратами ресурсов или есть вероятность, что объект или его часть не будут использованы.

### Пример

Для этого в котлине есть делегированное свойство `by lazy`.

```kt
class LazyExample {
    val lazyVal: Int by lazy {
        println("LazyVal init")
        1
    }

    init {
        println("LazyExample init")
    }
}


fun main() {
    var lazy = LazyExample()
    println(lazy.lazyVal)
    println(lazy.lazyVal)
}
```

## Материалы для самостоятельного изучения

* https://refactoring.guru/ru/design-patterns/creational-patterns