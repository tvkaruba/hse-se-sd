# Корутины

## Введение

<details>
    <summary>Чем отличается асинхронность и параллельность?</summary>

    Параллельные вычисления позволяют выполнять несколько задач одновременно, а асинхронность позволяет не блокировать основной ход приложения во время выполнения задачи, которая занимает продолжительное время.

</details>
</br>

Корутины (Coroutines) — это шаблон проектирования для написания асинхронных программ для одновременного выполнения нескольких задач.

В асинхронных программах несколько задач выполняются параллельно в отдельных потоках, не дожидаясь завершения других задач. Потоки являются дорогостоящим ресурсом, и слишком большое количество потоков приводит к снижению производительности из-за высокого потребления памяти и использования ЦП.

Корутины — это альтернативный способ написания асинхронных программ, но он гораздо более легкий по сравнению с потоками. Это вычисления, которые выполняются поверх потоков. Мы можем приостановить корутину, чтобы другие корутины могли работать в том же потоке. Далее мы можем возобновить работу корутины в том же или другом потоке. Когда корутина приостанавливается, соответствующие вычисления приостанавливаются, удаляются из потока и сохраняются в памяти, оставляя поток свободным для выполнения других действий. Таким образом, мы можем запускать множество корутин одновременно, используя лишь небольшой пул потоков, тем самым используя очень ограниченные системные ресурсы.

Примерно так выглядит вызов функции в отдельном потоке без корутин:

```kt
import kotlin.concurrent.thread

fun main() {
    println("My program runs: ${Thread.currentThread().name}")

    thread {
        longRunningTask()
    }

    println("My program run ends: ${Thread.currentThread().name}")
}

fun longRunningTask() {
    println("executing longRunningTask on: ${Thread.currentThread().name}")

    Thread.sleep(1000)

    println("longRunningTask ends on thread: ${Thread.currentThread().name}")
}
```

Корутины очень часто характеризуют как “легковесные потоки”, что по сути означает, что мы можем выполнять код с корутинами аналогично тому, как мы выполняем код с потоками. Давайте перепишем предыдущую программу, чтобы она запускала долго выполняющуюся функцию в корутине, а не в отдельном потоке:

```kt
import kotlinx.coroutines.*

fun main() = runBlocking {
    println("My program runs: ${Thread.currentThread().name}")

    launch {
        longRunningTask()
    }

    println("My program run ends: ${Thread.currentThread().name}")
}

suspend fun longRunningTask() {
    println("executing longRunningTask on: ${Thread.currentThread().name}")

    delay(1000)

    println("longRunningTask ends on thread: ${Thread.currentThread().name}")
}
```

## Suspend-функции

Поток, выполняющий обычную функцию, блокирует работу других функций до завершения ее выполнения. Если функция будет долго выполняться, например, из-за необходимости получить данные по сети через какой-нибудь внешний API, то это негативно скажется на производительности всей программы. Чтобы избежать возникновения такого рода проблем, можно заменить обычную функцию на suspend-функцию и вызвать ее из области видимости корутины. Вызов suspend-функции приостанавливает выполнение функции и позволяет потоку выполнять другие действия. Через некоторое время приостановленная функция может быть возобновлена в том же или другом потоке.

Suspend-функция — это самый главный элемент построения корутин. Она, как и любая другая обычная функция, может принимать один или несколько аргументов и что-нибудь возвращать. Синтаксис suspend-функции аналогичен синтаксису обычной функции и объявляется с добавлением ключевого слова suspend. Функции, объявленные с ключевым словом suspend, преобразуются во время компиляции и становятся асинхронными. Важно также понимать, что suspend-функции могут быть вызваны только другой suspend-функцией или из корутины.

```kt
fun main() = runBlocking {
    println("${Instant.now()}: My program runs: ${Thread.currentThread().name}")

    val productId = findProduct()

    launch (Dispatchers.Unconfined) {
        val price = fetchPrice(productId)
    }
    updateProduct()

    println("${Instant.now()}: My program run ends: ${Thread.currentThread().name}")
}

suspend fun fetchPrice(productId: String) : Double {
    println("${Instant.now()}: fetchPrice starts on: ${Thread.currentThread().name} ")

    delay(2000)

    println("${Instant.now()}: fetchPrice ends on: ${Thread.currentThread().name} ")
    return 234.5
}

fun findProduct() : String {
    println("${Instant.now()}: findProduct on: ${Thread.currentThread().name}")
    return "P12333"
}

fun updateProduct() : String {
    println("${Instant.now()}: updateProduct on: ${Thread.currentThread().name}")
    return "Product updated"
}
```

## Области видимости и билдеры корутин

Как уже говорилось в предыдущих разделах, suspend-функции можно запускать только в областях видимости корутин. Для запуска новой корутины мы используем корутин-билдер (coroutine builder), и для того, чтобы очертить ее жизненный цикл, мы устанавливаем соответствующую область видимости (coroutine scope). Область видимости корутины предоставляет методы для управления жизненным циклом корутины, позволяющие запускать и останавливать ее. Всего существует три корутин-билдера: runBlocking{}, launch{} и async{}.

### runBlocking

Корутины более эффективны, чем потоки, поскольку они приостанавливают и возобновляют выполнение вместо того, чтобы блокировать его. Однако в некоторых специфических случаях нам необходимо именно заблокировать поток. Например, в функции main() необходимо блокировать поток, иначе программа завершится, не дождавшись завершения работы корутины. Корутин-билдер runBlocking запускает корутину, блокируя текущий выполняющийся поток, пока не будет завершен весь код в корутине. Поскольку runBlocking{} блокирует выполняющийся поток, он редко используется внутри кода в телах функций, так как потоки — это дорогие ресурсы, и блокировать их неэффективно и нежелательно.

Функция принимает два параметра:

* context: Предоставляет контекст корутины, представленный интерфейсом CoroutineContext, который является индексированным набором инстансов Element.
* block: Вызываемый код корутины. Он принимает функцию типа suspend CoroutineScope.() -> Unit

### launch

Функция launch{} запускает новую корутину, которая не возвращает вызывающей стороне никакого результата. Она не блокирует текущий поток.

Функция принимает три параметра и возвращает объект Job:

* context: Предоставляет контекст корутины, представленный интерфейсом CoroutineContext, который является индексированным набором инстансов Element.
* start: Опция запуска корутины. По умолчанию используется значение CoroutineStart.DEFAULT, которое запланирует корутину на немедленное выполнение. Мы также можем установить опцию start в CoroutineStart.LAZY для ленивого запуска корутины.
* block: Вызываемый код корутины. Он принимает функцию типа suspend CoroutineScope.() -> Unit

```kt
val job: Job = launch (EmptyCoroutineContext, CoroutineStart.DEFAULT) {
    longRunningTask()
}
```

Объект job мы можем использовать для управления выполнением карутины (приостановить, отменить, продолжить выполнение).

### async

async — это еще один способ запуска корутины. Иногда, когда мы запускаем корутину, нам может потребоваться значение, которое должно быть возвращено из этой корутины обратно в поток, который ее запустил. async запускает корутину параллельно, аналогично launch. Однако перед запуском очередной корутины он дожидается завершения уже запущенной.

Функция async{} принимает те же три параметра, что и функция launch{}, но вместо Job возвращает инстанс Deferred<T>. Получить из инстанса Deferred<T> результат вычислений, выполняемых в корутине, мы можем вызвав метод await().

```kt
fun main() = runBlocking {
    println("program runs: ${Thread.currentThread().name}")

    val taskDeferred = async {
        generateUniqueID()
    }

    val taskResult = taskDeferred.await()
    println("program run ends:  ${taskResult} ${Thread.currentThread().name}")
}

suspend fun generateUniqueID(): String {
    println("executing generateUniqueID on: ${Thread.currentThread().name}")

    delay(1000)

    println("generateUniqueID ends on thread: ${Thread.currentThread().name}")
    return UUID.randomUUID().toString()
}
```

### Объединение элементов контекста

```kt
fun main() = runBlocking {
    launch(Dispatchers.Default + CoroutineName("test")) {
        println("I'm working in thread ${Thread.currentThread().name}")
    }
}
```

## Диспетчеры корутин

Диспетчер корутины определяет, какой поток или пул потоков корутина будет использовать для своего выполнения. Все корутины выполняются в контексте, представленном интерфейсом CoroutineContext. CoroutineContext представляет собой индексированный набор элементов и доступен внутри корутины через свойство CoroutineContext. Важным элементом этого индексированного набора является диспетчер корутины. Диспетчер корутины может ограничить выполнение корутины определенным потоком, передать ее в пул потоков или позволить ей выполняться без ограничений. CoroutineContext используется для явного указания диспетчера для новой корутины. В Kotlin существует несколько реализаций CoroutineDispatchers, которые мы можем указывать при создании корутин.

### Наследование диспетчера от родительской корутины

Когда корутина запускается в CoroutineScope другой корутины, она наследует свой контекст через CoroutineScope.coroutineContext, и Job новой корутины становится дочерним по отношению к Job родительской корутины. Когда родительская корутина отменяется, все ее потомки также рекурсивно отменяются.

Однако это отношение родитель-потомок может быть явно переопределено одним из двух способов:

* Если при запуске корутины явно указана другая область видимости (например, GlobalScope.launch), то она не наследует Job от родительской области видимости.
* Когда в качестве контекста для новой корутины передается другой объект Job (как показано в примере ниже), он переопределяет Job родительской области видимости.

```kt
fun main() = runBlocking<Unit> {
    val request = launch {

        launch(Job()) { 
            println("job1: I run in my own Job and execute independently!")
            delay(1000)
            println("job1: I am not affected by cancellation of the request")
        }

        launch {
            delay(100)
            println("job2: I am a child of the request coroutine")
            delay(1000)
            println("job2: I will not execute this line if my parent request is cancelled")
        }
    }
    delay(500)
    request.cancel()
    delay(1000)
    println("main: Who has survived request cancellation?")
}
```

### Диспетчер по умолчанию для выполнения операций с интенсивными вычислениями

Диспетчер по умолчанию используется, когда в области видимости явно не указан другой диспетчер. Он представлен Dispatchers.Default и использует общий фоновый пул потоков. Пул потоков имеет размер, равный количеству ядер на машине, на которой выполняется наш код. Мы также можем использовать limitedParallelism для ограничения количества активно выполняемых параллельно корутин, как показано в данном примере ниже:

```kt
fun main() = runBlocking {
    repeat(1000) {
      launch(Dispatchers.Default.limitedParallelism(3)) {
        println("Default: running in thread ${Thread.currentThread().name}")
            longTask()
        }
    }
}

suspend fun longTask() {
    println("executing longTask on...: ${Thread.currentThread().name}")
    delay(1000)
    println("longTask ends on thread ...: ${Thread.currentThread().name}")
}
```

### Создание нового потока с помощью newSingleThreadContext

newSingleThreadContext создает новый поток, который будет предназначен только для выполнения данной корутины. Этот диспетчер гарантирует, что корутина будет постоянно выполняться в определенном нами потоке.

### Запуск без ограничений на выполнение с помощью Dispatchers.Unconfined

Диспетчер Dispatchers.Unconfined запускает корутину в вызывающем потоке, но только до первой приостановки. После приостановки корутина возобновляет работу в потоке, который полностью определяется вызванной suspend-функцией.

Диспетчер Unconfined целесообразно использовать для тех корутин, которые не сильно нагружают процессор и не обновляют общие данные (например, пользовательский интерфейс), связанные с каким-нибудь конкретным потоком. Этот диспетчер не стоит использовать в общем коде. Он полезен в ситуациях, когда какая-нибудь операция в корутине должна быть выполнена немедленно.

## Отмена выполнения корутины

Мы можем захотеть отменить долго выполняющиеся задачи до их завершения. Примером ситуации, когда мы хотим отменить задачу, может служить переход на другой экран в приложении с пользовательским интерфейсом, и результат выполнения долго выполняющейся функции нас больше не интересует.

Объект Job предоставляет метод cancel() для отмены запущенной корутины, который мы можем использовать, как показано в данном примере:

```kt
fun main() = runBlocking{
    println("My program runs...: ${Thread.currentThread().name}")

    val job:Job = launch {
        longRunningFunction()
    }

    delay(1500)
    job.cancel()
    job.join()

    // job.cancelAndJoin()

    println("My program run ends...: ${Thread.currentThread().name}")
}

suspend fun longRunningFunction(){
    repeat(1000){ i ->
        println("executing :$i step on thread: ${Thread.currentThread().name}")
        delay(600)
    }
}
```

Для того чтобы код корутины был отменяемым, мы должные его к этому подготовить. Нам необходимо убедиться, что весь код в корутине адекватно отреагирует на отмену, периодически или перед началом выполнения любой длительной задачи делая проверки статуса отмены.

Мы можем периодически вызывать suspend-функцию yield для проверки статуса отмены корутина и уступать поток текущей корутины, чтобы позволить другим корутинам работать на том же потоке:

```kt
fun main() = runBlocking{
    try {
        val job1 = launch {
            repeat(20){
                println(
                 "processing job 1: ${Thread.currentThread().name}")
                yield()
            }
        }

        val job2 = launch {
            repeat(20){
                println(
                 "processing job 2: ${Thread.currentThread().name}")
                yield()
            }
        }
    } catch (e: CancellationException) {
        // ...
    }
}
```

Мы также можем явно проверить статус отмены запущенной корутины с помощью свойства isActive, которое является расширением и доступно внутри корутины через объект CoroutineScope:

fun main() = runBlocking{
    println("program runs...: ${Thread.currentThread().name}")

    val job:Job = launch {
        val files = File ("<File Path>").listFiles()
        var loop = 0

        while (loop < files.size-1 ) {
            if(isActive) {
                readFile(files.get(++loop))
            }
        }
    }

    delay(1500)
    job.cancelAndJoin()

    println("program run ends...: ${Thread.currentThread().name}")
}

## Как они работают

Корутины не основаны ни на функциональности JVM, ни на функциональности операционной системы. Вместо этого корутины и прерываемые функции преобразуются компилятором в конечный автомат состояний, который может перехватывать прерывания и отправлять их в прерываемые функции, сохраняя при этом состояние. Все это возможно благодаря Continuation, который добавляется компилятором, в виде дополнительного неявного параметра, в каждый вызов прерываемой функции. Это так называемый стиль Continuation-passing.

## Что почитать

* https://kotlinlang.org/docs/coroutines-guide.html
