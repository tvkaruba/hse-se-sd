# Основы Котлина

## Переменные

```kt
var name: type = value
val name: type?
const val name = value
```

* Ключевое слово `var` используется для определния изменяемых переменных, а `val` для неизменяемых;
* Если присвоение происходит сразу при инициализации, то тип можно опускать;
* С помощью `?` мы показываем что эта переменная может иметь значение null;
* Также существуют константы, их значение определяется во время компиляции и не может быть изменено позднее;
* Константы могут быть объявлены только на самом верхнем уровне (вне функций и классов).

## Типы данных

### Целочисленные типы

```kt
val a: Byte = 10
val b: UShort = 45U
val c: Int = 0x0A1 // 161
val c: Int = 0b0101 // 5
```

* Byte: хранит целое число от -128 до 127
* Short: хранит целое число от -32 768 до 32 767
* Int: хранит целое число от -2 147 483 648 до 2 147 483 647
* Long: хранит целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807

Также существуют типы UByte, UShort, UInt, ULong, которые хранят типы без знака.

Для передачи значений объектам, которые представляют беззнаковые целочисленные типы данных, после числа указывается суффикс U. Кроме чисел в десятичной системе мы можем определять числа в двоичной (префикс 0b) и шестнадцатеричной (префикс 0x) системах.

### Числа с плавающей точкой

```kt
val h: Double = 1.78
val pi: Float = 3.14F
```
* Float: хранит число с плавающей точкой от -3.4*1038 до 3.4*1038
* Double: хранит число с плавающей точкой от ±5.0*10-324 до ±1.7*10308

### Логический тип

* Boolean: может хранить либо true, либо false

### Строки

```kt
val a: Char = 'A'
val name: String = "string"
val template = "Hello, $name"
```

* Char: представляет отдельный символ. Есть ряд особых символов: \t, \r, \n, \\', \\", \\\\
* String: представляет последовательность символов, заключенную в двойные кавычки, либо в тройные двойные кавычки (для многострочных переменных).

### Это JavaScript?

```kt
var name: Any = "Tom"
name = 42
```

* Any: позволяет присвоить переменной данного типа любое значение.

## Математические операции

Буквально все как в шарпах. Немного отличаются операторы побитовых операций, но когда вы ими пользовались?

## Условные операции

Также все аналогично шарпам. Кроме того есть удобный оператор вхождения в диапазон:

```kt
val c = 4
val d = c in 11..15
```

## Условные конструкции

```kt
val c = if (a == b) {
    println("a = b")
    a
}
else {
    println("a != b")
    b
}
```

Есть стандартный if-else. Из интересного: есть вариант конструкции с возвратом значения. По сути это местная тернарная операция.

```kt
when (a + b) {
    10 -> println("a + b = 10")
    20 -> println("a + b = 20")
    30 -> println("a + b = 30")
    else -> println("Undefined")
}

val rate = when (sum) {
    in 100..999 -> 10
    in 1000..9999 -> 15
    else -> 20
}
```

А это местный switch-case. Также есть вариант с возвратом значений. В целом круто что в котлине можно сравнивать значения не только с константами, но и с вычисляемыми выражениями. Но патерн матчинг тут конечно послабее шарпового.

## Циклы

```kt
while (sum < 1000) {
    sum = sum + 1
}

do {
    sum = sum + 1
} while (sum < 1)
```

while и do-while циклы работают стандартно, поэтому давайте сразу перейдем к for.

```kt
var sum = 0
for (i in 1..10) {
    sum += i
}

for(number in numbers){
    println("$number")
}

for (i in 10 downTo 1 step 2) {
    sum += i
}

repeat(10) {
    val temp = sum
    sum += lastSum
    lastSum = temp
}
```

Цикл `for` в котлине работает либо как `foreach` в других языках, для этого тут используется синтаксис диапазонов. Диапазон представляет набор значений или закрытый интервал. С помощью `downTo` можно построить диапазон в обратном порядке, `step` позволяет задать шаг, на который будут изменяться последующие элементы прогрессии, `until` позволяет не включать верхнюю границу в диапазон, `in` возвращает true, если объект имеется в диапазоне.

Если перменная цикла вообще не нужна, то можно использовать `repeat`. Также стоит отметить что `continue` и `break` в котлине тоже есть и работают как обычно.

## Коллекции

### Массивы

```kt
val numbers: Array<Int> = arrayOf(1, 2, 3, 4, 5)

val numbers = Array(3, {5}) // [5, 5, 5]

val table = Array(3, { Array(3, {0}) })
table[0] = arrayOf(1, 2, 3)     // первая строка таблицы
table[1] = arrayOf(4, 5, 6)     // вторая строка таблицы
table[2] = arrayOf(7, 8, 9)     // третья строка таблицы
```

Просто массивы... Кроме того существуют дополнительные типы BooleanArray, ByteArray, ShortArray, IntArray, LongArray, CharArray, FloatArray и DoubleArray, которые позволяют создавать массивы для определенных типов. Можно добавлять элементы в конец через `+=`.

### List

### Set

### Map

## Функции

```kt
fun displayUser(name: String, age: Int = 18, position: String = "unemployed") // Можно назначать аргументам значения по умолчанию, тогда не обязательно их передавать
displayUser("Tom")

displayUser("Tom", position="Manager", age=28) // Используя именованные аргументы можно менять их порядок
```

По умолчанию все параметры функции равносильны val-переменным, поэтому их значение нельзя изменить, но если параметр это какой-то сложный объект, то отдельные значения в этом объекте можно изменять.


```kt
fun printStrings(vararg strings: String)

val nums = intArrayOf(1, 2, 3, 4)
changeNumbers(*nums, koef=2)
```

`vararg` это аналаг `params`, он может принимать 1 или несколько значений. Внутри функции мы работаем с ним как с массивом. `*` позволяет передать элементы из массива в качестве значений параметра.

Если функция не возвращает какого-либо результата, то она неявно возвращает значение типа Unit. Этот тип аналогичен типу void и указывает, что функция ничего не возвращает.

```kt
fun foo(x: Int) : Int = x * x // Однострочная функция (без тела)

fun sum(a: Int, b: Int) : Int{
    return a + b
}
fun sum(a: Double, b: Double) : Double{
    return a + b
}
```

В котлине функции так же можно перегружать, но возвращаемый тип при этом не учитывается.

```kt
fun main() {
    val message: () -> Unit 
    message = ::hello
    message()

    // анонимная функция
    val sum = fun(x: Int, y: Int): Int = x + y 

    // передаем функцию в другую функцию
    displayMessage(message)
}
 
fun hello(){
    println("Hello Kotlin")
}

fun displayMessage(mes: () -> Unit){
    mes()
}
```

Функции-переменные (аналог делегатов).

```kt
fun main() {
    val sum: (Int, Int) -> Int = {x, y -> x + y }
    doOperation(3, 4, sum)
    doOperation(3, 4, {a, b -> a * b})
    doOperation(3, 4) {a, b -> a * b}
}

fun doOperation(x: Int, y: Int, op: (Int, Int) ->Int){
 
    val result = op(x, y)
    println(result)
}
```
Лямбда-функции.