# KTOR

Ktor — это асинхронная платформа для создания микросервисов, веб-приложений и многого другого, написанная на Kotlin.

В общем это как спринг, только более легковесное и бедное что ли... В целом напиминает гошные фреймворки. Для микросервисов или домашек ок, что-то большое я бы писать на нем не стал.

## Создание проекта

В целом все стандартно, выбираем шаблок ктор, билд систему, версию ктора. Потом мы подходим к выбору веб сервера который будет использоваться фреймворком. Как будто дефолтный нетти - в большинстве случаев оптимальный выбор с точки зрения соотношения перфоманса/геморроя. Ну а конфигурацию и вовсе можете делать на свой вкус, проще всего наверное все настроить в коде, но тогда вы теряете некоторую гибкость в изменении конфигурации, поэтому в реалдьности ее обычно стараются максимально вынести в отдельные файлы.

## API

API (Application programming interface) — это контракт, который предоставляет программа.

### REST API (Representational State Transfer)

REST API является наиболее распространенным типом API в клиент-серверной архитектуре и имеет ряд свойств — например, отсутствие хранения состояния и кэшируемость. REST API построен на стандартных протоколах HTTP и обычно возвращает данные в формате JSON, хотя может поддерживать и другие форматы.

REST API использует стандартные HTTP-методы для взаимодействия, включая GET, POST, PUT, DELETE и другие. Каждый метод соответствует определенному типу действий, которые могут быть выполнены над ресурсами API.

Простота и гибкость REST API сделали его лучшим выбором для многих разработчиков, но при работе с большими объемами данных он может быть неэффективными, так как для получения всех необходимых данных может требоваться несколько запросов.

Существуют 6 принципов REST:

* Клиент-серверная архитектура
* Stateless
* Кэширование
* Единообразие интерфейса
* Layered system
* Code on demand

Принцип 1. Клиент-серверная архитектура

Сама концепция клиент-серверной архитектуры заключается в разделении некоторых зон ответственности: в разделении функций клиента и сервера. Что это означает?

Например, мы разделяем нашу систему так, что клиент (допустим, это мобильное приложение) реализует только функциональное взаимодействие с сервером. При этом сервер реализует в себе логику хранения данных, сложные взаимодействия со смежными системами и т.д.

Принцип 2. Stateless

Принцип заключается в том, что сервер не должен хранить у себя информацию о сессии с клиентом. Он должен в каждом запросе получать всю информацию для обработки.

Принцип 3. Кэширование

В оригинале этот принцип говорит нам о том, что каждый ответ сервера должен иметь пометку, можно ли его кэшировать.

Принцип 4. Единообразие интерфейса. HATEOAS

Hypermedia as the Engine of Application State (HATEOAS) — одно из ограничений REST, согласно которому сервер возвращает не только ресурс, но и его связи с другими ресурсами и действия, которые можно с ним совершить.

Принцип 5. Layered system (слоистая архитектура)

В предыдущих схемах мы рассматривали сторону клиента и сторону сервера, но не думали, что между ними могут быть посредники. В реальной жизни между ними могут быть, к примеру, proxy-сервера, роутеры, балансировщики — все, что угодно. И то, по какому пути запрос проходит от клиента до сервера, мы часто не можем знать. Концепция слоистой архитектуры заключается в том, что ни клиент, ни сервер не должны знать о том, как происходит цепочка вызовов дальше своих прямых соседей.

Принцип 6. Code on done (код по требованию)
Идея передачи некоторого исполняемого кода (по сути какой-то программы) от сервера клиенту.

### SOAP API (Simple Object Access Protocol)

SOAP — это протокол для обмена структурированной информацией в веб-сервисах с использованием XML. Он обладает высокой расширяемостью и позволяет осуществлять обмен данными через несколько различных транспортных протоколов, включая HTTP, SMTP и другие.

API SOAP известны своей надежностью и часто используются в энтерпрайз-разработке. Они предлагают встроенную обработку ошибок и их можно использовать с различными сетевыми протоколами. Однако зависимость SOAP от XML может приводить к большим объемам передаваемых данных, что делает его менее эффективным по сравнению с другими API в каких-то сценариях использования.

### WebSocket API

WebSocket API обеспечивает постоянный, полнодуплексный канал связи между клиентом и сервером. В отличие от REST и SOAP, которые придерживаются формата «запрос-ответ», WebSocket сохраняет соединение открытым, что позволяет передавать данные в режиме реального времени. Это делает WebSocket API идеальным для приложений, требующих функциональности в реальном времени, таких как чат-приложения, онлайн-игры и системы отслеживания в реальном времени.

Несмотря на свою мощь, WebSocket API могут быть более сложными в реализации и требуют больше ресурсов для поддержания открытых соединений.

### gRPC API (Google Remote Procedure Call)

#### Что это вообще такое

RPC — remote procedure call, удаленный вызов процедур. Клиент отправляет запрос процессу на сервере, который постоянно прослушивает удаленные вызовы. В запросе есть вызываемая серверная функция и все передаваемые параметры. Процесс ловит запрос и выполняет его. Взаимодействие между клиентом и сервером происходит так, как если бы клиентский API-запрос был локальной операцией или запрос —  внутренним кодом сервера. 

gRPC — это фреймворк RPC от Google. gRPC и REST представляют собой два способа разработки API — механизма, который позволяет двум программным компонентам взаимодействовать друг с другом, используя набор определений и протоколов. Клиенты посылают на сервер информационные запросы — сервер предоставляет ответы. Главное отличие gRPC от REST:

* В gRPC один компонент, клиент, вызывает определенные функции в другом программном компоненте — сервере. При этом программная реализация клиента и сервера не имеет особого значения благодаря кроссплатформенности протокола gRPC. 
* В REST вместо вызова функций клиент запрашивает или обновляет данные на сервере.

gRPC поддерживает четыре типа взаимодействия: унарный (стандартный запрос-ответ), потоковая передача данных с сервера, потоковая передача данных от клиента и двунаправленная потоковая передача:

* Унарный (Unary RPC), 1—1. Синхронный запрос клиента, который блокируется, пока не будет получен ответ от сервера. Клиент ничего не может сделать до получения ответа или пока запрос не упадет по таймауту.
* Клиентский стрим (Client streaming RPC), N—1. При подключении сервера клиент начинает стримить сообщения на него. Клиент делает запрос на сервер в виде последовательности N сообщений и получает ответ в виде одного сообщения от сервера.
* Серверный стрим (Server streaming RPC), 1—N. При подключении клиента сервер открывает стрим и начинает отправлять сообщения. Клиент делает запрос на сервер в виде одного сообщения и получает ответ в виде последовательности N сообщений от сервера.
* Двунаправленный стрим (Bidirectional streaming), N—N. Клиент инициализирует соединение, создаются два стрима. В общем случае клиент делает запрос на сервер в виде последовательности N сообщений и получает ответ в виде последовательности N сообщений от сервера. Сервер может отправить изначальные данные при подключении или отвечать на каждый запрос клиента по типу пинг-понга. Два потока работают независимо, поэтому клиенты и серверы могут читать и писать в любом порядке. Например, сервер может дождаться получения всех клиентских сообщений, прежде чем записывать свои ответы, или он может поочередно читать сообщения, а затем сразу писать на них ответы. Возможна и какая-то другая комбинация чтения и записи. Порядок сообщений в каждом потоке сохраняется.

#### Как писать контракты

Контракт — это набор методов, объединенных в сервисы. Описание метода состоит из названия, сообщения запроса и сообщения ответа. В запросе и ответе можно как указать стандартные типы данных, так и составить свой объект с необходимым наполнением. Во втором случае потребуется придумать ему название и описать с ключевым словом message.

```proto
service Greeter{
	rpc SayHello (HelloRequest) returns (HelloReply) {} // Унарный
	rpc GladToSeeMe(HelloRequest) returns (stream HelloReply){} // Серверный стрим
	rpc GladToSeeYou(stream HelloRequest) returns (HelloReply){} // Клиентский стрим
	rpc BothGladToSee(stream HelloRequest) returns (stream HelloReply){} // Двунаправленный стрим
  }
```

Правила, по которым строится запрос:

Метод должен принимать что-то на вход и возвращать что-то на выходе — HelloRequest и HelloResponse. Если не нужно получать или отправлять какие-то данные, их можно заменить пустым значением google.protobuf.Empty. Тогда в ответ на запрос или в запросе не будут отправляться никакие данные, но придет код ответа. Ответ 2хх, если все успешно, или 4хх/5хх, если есть проблемы. Это позволяет снизить нагрузку на систему и повысить безопасность, передавая только самое необходимое.

В методе должны быть указаны типы данных, которыми он оперирует. Если тип данных заранее неизвестен, можно использовать google.protobuf.Any, который заменяет любой тип данных.

У поля в сообщении должен быть неповторяющийся порядковый номер. Если какое-то поле было использовано ранее и удалено, этот номер повторно использовать нельзя. Такие поля можно резервировать ключевым словом reserved или оставляя комментарии. 

Для описания контракта используются ключевые слова:

* ‘syntax’ — текущая версия синтаксиса. Сейчас, как правило, новые сервисы пишутся на proto3.
* ‘import’ — для импорта стандартных пакетов. Например, “google/protobuf/timestamp.proto” загрузит тип данных timestamp.
* ‘service’ — для объявления сервиса. В сервис объединяют GRPC-методы
* ‘rpc’ — для объявления метода: его названия и request-сообщения.
* ‘returns’ — для объявления ответа метода, response-сообщения.
* ‘message’ — для объявления объекта.
* ‘enum’ — для объявления перечисления.
* ‘repeated’ — для объявления повторяющегося поля.
* ‘reserved’ — для резервирования поля.
* ‘optional’ или ‘required’; — для объявления необязательного или обязательного поля. В proto3 этот функционал убран.
* ‘oneof’ — для объявления сложного поля, в котором можно получить одно из нескольких значений. Это довольно нагруженная и сложно обрабатываемая конструкция, которая может много весить и тратить кучу ресурсов, поэтому ее лучше не использовать, а заменить на что-нибудь другое. Например, на строку, в которой придет на самом деле json. 
* Целый набор стандартных типов данных вроде bool, string, int64 и других.

```proto
syntax = "proto3";

import "google/protobuf/any.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";

 
service ProductService{
	// метод добавления книги в каталог
	rpc AddProduct(AddProductRequest) returns (google.protobuf.Empty) {}
    // метод получения книги по ID
	rpc GetProductById(GetProductByIdRequest) returns (GetProductByIdResponse) {}
    // метод получения всех книг
	rpc GetProductsList(GetProductsListRequest) returns (GetProductsListResponse) {}
}

message AddProductRequest{
	BookInfo add_book_info = 1;
}

message BookInfo{
	// эти поля нельзя будет использовать
	reserved 6, 15, 9 to 11;
	// данные об авторе не определены однозначно, и может прийти любой тип (строка или массив, например)
	google.protobuf.Any author = 1;
	string name = 2;
	int32 price = 3;
	Type type = 4;
	bool in_store = 5;
	// в типе bytes можно передавать файлы, но лучше заменить на ссылку в s3
	bytes book_cover = 7;
	// здесь мы будем использовать только одно из перечисленных полей, для пользователя это выглядит как, например, динамичная форма ввода
	oneof additional_fields{
        // используем с TYPE_UNDEFINED — он пригодится, когда будут добавляться новые значения в enum Type: созданные объекты BookInfo примут этот тип по умолчанию
    	AdditionalFieldsUndefined additional_fields_undefined = 8;
    	AdditionalFieldsDetective additional_fields_detective = 12;
    	}
}

enum Type{
	TYPE_UNDEFINED = 0;
	TYPE_DETECTIVE = 1;
}

message AdditionalFieldsUndefined{
	string description = 1;
}

message AdditionalFieldsDetective{
	string description = 1;
	string period = 2;
}

message GetProductByIdRequest{
	// protobuf еще не знает, что такое uuid, поэтому его можно передать типами string, bytes или кастомным типом
	string id = 1;
}

message GetProductByIdResponse{
	string id = 1;
	BookInfo get_book_info = 2;
	google.protobuf.Timestamp created_at = 3;
}

// limit и offset нужны для пагинации на бэке. Если у нас бесконечная лента, можно вместо объекта GetProductsListRequest передать google.protobuf.Empty
message GetProductsListRequest{
	int32 limit = 1;
	int32 offset = 2;
}

message GetProductsListResponse{
	repeated BookInfo get_book_list_info = 1;
}
```

### GraphQL API 

Разработанный компанией Facebook, GraphQL представляет собой язык запросов к API и рабочую среду для выполнения этих запросов. В отличие от REST API, где вам нужно делать запросы к различным эндпоинтам, чтобы получить соответствующие данные, GraphQL позволяет сделать один единственный запрос, чтобы получить именно те данные, которые вам нужны.

В GraphQL пользователи определяют форму и размер ответа, что приводит к более эффективной загрузке данных и уменьшению избыточной выборки данных. Он отлично подходит для сложных систем и микросервисов, где данные распределены между различными сервисами.

## Протоколы

Протокол – это набор правил, определяющий, как узлы сети должны передавать данные друг другу.

Транспортный уровень основан на двух китах: Transmission Control Protocol и User Datagram Protocol

TCP/IP — это аббревиатура, которая обозначает два основных протокола, используемых в этой модели: протокол передачи контроля соединения (TCP) и протокол интернет-протокола (IP). TCP обеспечивает установление соединения между устройствами, управление потоком данных и контроль ошибок, а IP отвечает за передачу пакетов данных между устройствами в сети.

TCP/IP модель состоит из четырех уровней:

* Канальный уровень
* Межсетевой уровень
* Транспортный уровень
* Прикладной уровень

Канальный уровень отвечает за передачу данных по физической среде, он нас не интересует.

Межсетевой уровень отвечает за маршрутизацию пакетов данных между разными сетями.

Транспортный уровень обеспечивает эффективную передачу данных между устройствами в сети. На этом уровне используются протоколы, такие как TCP и UDP. TCP обеспечивает установление соединения между устройствами, контроль потока данных и обработку ошибок, а UDP предоставляет более быструю передачу данных без управления потоком и ошибками.

Прикладной уровень содержит различные протоколы, которые используются для обмена данными между приложениями, работающими на разных устройствах в сети. На этом уровне используются такие протоколы, как HTTP, FTP, SMTP и DNS.

## ORM (Object-Relational Mapping)

ORM — это технология программирования, которая создает слой между реляционными базами данных и объектно-ориентированными языками программирования без необходимости написания SQL-запросов.

Отображение объясняет, как объекты связаны с разными таблицами, используя эту информацию для преображения данных между ними. ORM генерирует код SQL для реляционной базы данных в ответ на изменения, которые приложение вносит в объект данных. Сопоставление ORM будет управлять потребностями приложения в данных, избавляя от написания низкоуровневого кода.

## DI (Dependency Injection)

Внедрение зависимостей — это стиль настройки объекта, при котором поля объекта задаются внешней сущностью. Другими словами, объекты настраиваются внешними объектами. DI — это альтернатива самонастройке объектов.

## Авторизация

Вообще, есть 3 шага:

* Идентификация — это процесс, когда система определяет, существует конкретный пользователь или нет. Делает она это с помощью идентификатора.
* Аутентификация — это процесс, когда пользователь вводит ключ подтверждая своё право на доступ к той или иной учётной записи и хранящейся в ней информации.
* Авторизация — проверка, что вам разрешен доступ к запрашиваемому ресурсу. Например, простой пользователь не сможет получить доступ к панели администрирования.

### Протоколы авторизации

* Аутентификация по паролю
* Аутентификация по сертификатам
* Аутентификация по токенам
* Стандарты OAuth и OpenID Connect

### Аутентификация по JWT токену

Официальное определение: 

JSON Web Token (JWT) — это JSON объект, который определен в открытом стандарте RFC 7519. Он считается одним из безопасных способов передачи информации между двумя участниками. Для его создания необходимо определить заголовок (header) с общей информацией по токену, полезные данные (payload), такие как id пользователя, его роль и т.д. и подписи (signature).

Простыми словами, JWT — это строка в следующем формате header.payload.signature.

Процесс аутентификации с использованием JWT токена выглядит следующим образом:

1. Сперва пользователь заходит на сервер аутентификации с помощью аутентификационного ключа (это может быть пара логин/пароль, либо Facebook ключ, либо Google ключ, либо ключ от другой учетки).
2. Затем сервер аутентификации создает JWT и отправляет его пользователю.
3. Когда пользователь делает запрос к API приложения, он добавляет к нему полученный ранее JWT.
4. Когда пользователь делает API запрос, приложение может проверить по переданному с запросом JWT является ли пользователь тем, за кого себя выдает. В этой схеме сервер приложения сконфигурирован так, что сможет проверить, является ли входящий JWT именно тем, что был создан сервером аутентификации.

#### Структура токена

JWT состоит из трех частей: заголовок header, полезные данные payload и подпись signature:

1. Хедер JWT содержит информацию о том, как должна вычисляться JWT подпись. Хедер — это тоже JSON объект, который выглядит следующим образом:

```
header = { "alg": "HS256", "typ": "JWT"}
```

Поле typ не говорит нам ничего нового, только то, что это JSON Web Token. Интереснее здесь будет поле alg, которое определяет алгоритм хеширования.

2. Payload — это полезные данные, которые хранятся внутри JWT. Эти данные также называют JWT-claims (заявки). Например, сервер аутентификации создает JWT с информацией об id пользователя.

```
payload = { "userId": "b08f86af-35da-48f2-8fab-cef3904660bd" }
```

Мы положили только одну заявку (claim) в payload. Вы можете положить столько заявок, сколько захотите. Существует список стандартных заявок для JWT payload — вот некоторые из них:

* iss (issuer) — определяет приложение, из которого отправляется токен.
* sub (subject) — определяет тему токена.
* exp (expiration time) — время жизни токена.

3. Подпись вычисляется с использование следующего псевдо-кода:

```
const SECRET_KEY = 'cAtwa1kkEy'
const unsignedToken = base64urlEncode(header) + '.' + base64urlEncode(payload)
const signature = HMAC-SHA256(unsignedToken, SECRET_KEY)
```

Алгоритм base64url кодирует хедер и payload, созданные на 1 и 2 шаге. Алгоритм соединяет закодированные строки через точку. Затем полученная строка хешируется алгоритмом, заданным в хедере на основе нашего секретного ключа.

#### Как работает проверка

Важно понимать, что использование JWT не скрывает и не маскирует данные автоматически. Причина, почему JWT используются — это проверка, что отправленные данные были действительно отправлены авторизованным источником. Как было продемонстрировано выше, данные внутри JWT закодированы и подписаны, обратите внимание, это не одно и тоже, что зашифрованы. Цель кодирования данных — преобразование структуры. Подписанные данные позволяют получателю данных проверить аутентификацию источника данных. Таким образом закодирование и подпись данных не защищает их. С другой стороны, главная цель шифрования — это защита данных от неавторизованного доступа.

Итак, наш сервер получает секретный ключ от сервера аутентификации во время установки аутентификационных процессов. Поскольку приложение знает секретный ключ, когда пользователь делает API-запрос с приложенным к нему токеном, приложение может выполнить тот же алгоритм подписывания к JWT, что в шаге 3. Приложение может потом проверить эту подпись, сравнивая ее со своей собственной, вычисленной хешированием. Если подписи совпадают, значит JWT валидный, т.е. пришел от проверенного источника. Если подписи не совпадают, значит что-то пошло не так — возможно, это является признаком потенциальной атаки. Таким образом, проверяя JWT, приложение добавляет доверительный слой между собой и пользователем.

А что, если этот секретный ключ украдут? Тогда кто-то еще сможет входить на сервер под вашим именем, причём мы об этом можем даже не узнать. Такого сценария мы не хотим допустить. Например для этого можно сделать токен короткоживущим, но мы же не будем заставлять пользоваться перелогиниваться каждые полчаса...

#### Refresh token

Обновим определния токенов:

Токены доступа (JWT) — это токены, с помощью которых можно получить доступ к защищенным ресурсам. Они короткоживущие, но многоразовые. В них может содержаться дополнительная информация, например, время жизни или IP-адрес, откуда идет запрос. Все зависит от желания разработчика.

Рефреш токен (RT) — эти токены выполняют только одну специфичную задачу — получение нового токена доступа. И на этот раз без сервера авторизации не обойтись. Они долгоживущие, но одноразовые.

Основной сценарий использования такой: как только старый JWT истекает, то с ним мы уже не можем получить приватные данные, тогда отправляем RT и нам приходит новая пара JWT+RT. С новым JWT мы снова можем обращаться к приватным ресурсам. Конечно, рефреш токен тоже может протухнуть, но случится это не скоро, поскольку живет он намного дольше своего собрата.

Ключевая идея разделения токенов состоит в том, что, с одной стороны, токены авторизации позволяют нам легко проверять пользователя без участия сервера авторизации, просто сравнением подписей. C другой стороны у нас есть рефреш токен, который позволяют нам обновить токен доступа без ввода пароля от пользователя, но в этом случае нам все-таки потребуется выполнить дорогую операцию обращения к серверу авторизации.

Благодаря такому подходу мы уменьшаем задержку по времени обращения к серверу latency, да и сама серверная логика становится сильно проще. А с точки зрения безопасности, если у нас всё-таки украли токен доступа, то воспользоваться им смогут только ограниченное время — не больше времени его жизни. Чтобы злоумышленник смог пользоваться дольше — ему потребуется украсть еще и рефреш, но тогда настоящий пользователь узнает, что его взломали, поскольку его выкинет из системы. И стоит такому пользователю снова войти в систему, он получит обновленную пару JWT+RT, а украденные превратятся в тыкву.